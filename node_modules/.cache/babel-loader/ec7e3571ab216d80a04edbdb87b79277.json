{"ast":null,"code":"'use strict';\n\nvar UNICODE = require('../common/unicode'); //Aliases\n\n\nvar $ = UNICODE.CODE_POINTS;\n\nexports.assign = function (tokenizer) {\n  //NOTE: obtain Tokenizer proto this way to avoid module circular references\n  var tokenizerProto = Object.getPrototypeOf(tokenizer),\n      tokenStartOffset = -1,\n      tokenCol = -1,\n      tokenLine = 1,\n      isEol = false,\n      lineStartPosStack = [0],\n      lineStartPos = 0,\n      col = -1,\n      line = 1;\n\n  function attachLocationInfo(token) {\n    /**\n     * @typedef {Object} LocationInfo\n     *\n     * @property {Number} line - One-based line index\n     * @property {Number} col - One-based column index\n     * @property {Number} startOffset - Zero-based first character index\n     * @property {Number} endOffset - Zero-based last character index\n     */\n    token.location = {\n      line: tokenLine,\n      col: tokenCol,\n      startOffset: tokenStartOffset,\n      endOffset: -1\n    };\n  } //NOTE: patch consumption method to track line/col information\n\n\n  tokenizer._consume = function () {\n    var cp = tokenizerProto._consume.call(this); //NOTE: LF should be in the last column of the line\n\n\n    if (isEol) {\n      isEol = false;\n      line++;\n      lineStartPosStack.push(this.preprocessor.sourcePos);\n      lineStartPos = this.preprocessor.sourcePos;\n    }\n\n    if (cp === $.LINE_FEED) isEol = true;\n    col = this.preprocessor.sourcePos - lineStartPos + 1;\n    return cp;\n  };\n\n  tokenizer._unconsume = function () {\n    tokenizerProto._unconsume.call(this);\n\n    isEol = false;\n\n    while (lineStartPos > this.preprocessor.sourcePos && lineStartPosStack.length > 1) {\n      lineStartPos = lineStartPosStack.pop();\n      line--;\n    }\n\n    col = this.preprocessor.sourcePos - lineStartPos + 1;\n  }; //NOTE: patch token creation methods and attach location objects\n\n\n  tokenizer._createStartTagToken = function () {\n    tokenizerProto._createStartTagToken.call(this);\n\n    attachLocationInfo(this.currentToken);\n  };\n\n  tokenizer._createEndTagToken = function () {\n    tokenizerProto._createEndTagToken.call(this);\n\n    attachLocationInfo(this.currentToken);\n  };\n\n  tokenizer._createCommentToken = function () {\n    tokenizerProto._createCommentToken.call(this);\n\n    attachLocationInfo(this.currentToken);\n  };\n\n  tokenizer._createDoctypeToken = function (initialName) {\n    tokenizerProto._createDoctypeToken.call(this, initialName);\n\n    attachLocationInfo(this.currentToken);\n  };\n\n  tokenizer._createCharacterToken = function (type, ch) {\n    tokenizerProto._createCharacterToken.call(this, type, ch);\n\n    attachLocationInfo(this.currentCharacterToken);\n  };\n\n  tokenizer._createAttr = function (attrNameFirstCh) {\n    tokenizerProto._createAttr.call(this, attrNameFirstCh);\n\n    this.currentAttrLocation = {\n      line: line,\n      col: col,\n      startOffset: this.preprocessor.sourcePos,\n      endOffset: -1\n    };\n  };\n\n  tokenizer._leaveAttrName = function (toState) {\n    tokenizerProto._leaveAttrName.call(this, toState);\n\n    this._attachCurrentAttrLocationInfo();\n  };\n\n  tokenizer._leaveAttrValue = function (toState) {\n    tokenizerProto._leaveAttrValue.call(this, toState);\n\n    this._attachCurrentAttrLocationInfo();\n  };\n\n  tokenizer._attachCurrentAttrLocationInfo = function () {\n    this.currentAttrLocation.endOffset = this.preprocessor.sourcePos;\n    if (!this.currentToken.location.attrs) this.currentToken.location.attrs = {};\n    /**\n     * @typedef {Object} StartTagLocationInfo\n     * @extends LocationInfo\n     *\n     * @property {Dictionary<String, LocationInfo>} attrs - Start tag attributes' location info.\n     */\n\n    this.currentToken.location.attrs[this.currentAttr.name] = this.currentAttrLocation;\n  }; //NOTE: patch token emission methods to determine end location\n\n\n  tokenizer._emitCurrentToken = function () {\n    //NOTE: if we have pending character token make it's end location equal to the\n    //current token's start location.\n    if (this.currentCharacterToken) this.currentCharacterToken.location.endOffset = this.currentToken.location.startOffset;\n    this.currentToken.location.endOffset = this.preprocessor.sourcePos + 1;\n\n    tokenizerProto._emitCurrentToken.call(this);\n  };\n\n  tokenizer._emitCurrentCharacterToken = function () {\n    //NOTE: if we have character token and it's location wasn't set in the _emitCurrentToken(),\n    //then set it's location at the current preprocessor position.\n    //We don't need to increment preprocessor position, since character token\n    //emission is always forced by the start of the next character token here.\n    //So, we already have advanced position.\n    if (this.currentCharacterToken && this.currentCharacterToken.location.endOffset === -1) this.currentCharacterToken.location.endOffset = this.preprocessor.sourcePos;\n\n    tokenizerProto._emitCurrentCharacterToken.call(this);\n  }; //NOTE: patch initial states for each mode to obtain token start position\n\n\n  Object.keys(tokenizerProto.MODE).map(function (modeName) {\n    return tokenizerProto.MODE[modeName];\n  }).forEach(function (state) {\n    tokenizer[state] = function (cp) {\n      tokenStartOffset = this.preprocessor.sourcePos;\n      tokenLine = line;\n      tokenCol = col;\n      tokenizerProto[state].call(this, cp);\n    };\n  });\n};","map":null,"metadata":{},"sourceType":"script"}