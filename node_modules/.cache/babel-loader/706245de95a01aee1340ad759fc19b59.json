{"ast":null,"code":"'use strict';\n\nvar OpenElementStack = require('../parser/open_element_stack'),\n    Tokenizer = require('../tokenizer'),\n    HTML = require('../common/html'); //Aliases\n\n\nvar $ = HTML.TAG_NAMES;\n\nfunction setEndLocation(element, closingToken, treeAdapter) {\n  var loc = element.__location;\n  if (!loc) return;\n  /**\n   * @typedef {Object} ElementLocationInfo\n   * @extends StartTagLocationInfo\n   *\n   * @property {StartTagLocationInfo} startTag - Element's start tag location info.\n   * @property {LocationInfo} endTag - Element's end tag location info.\n   */\n\n  if (!loc.startTag) {\n    loc.startTag = {\n      line: loc.line,\n      col: loc.col,\n      startOffset: loc.startOffset,\n      endOffset: loc.endOffset\n    };\n    if (loc.attrs) loc.startTag.attrs = loc.attrs;\n  }\n\n  if (closingToken.location) {\n    var ctLocation = closingToken.location,\n        tn = treeAdapter.getTagName(element),\n        // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing tag and\n    // for cases like <td> <p> </td> - 'p' closes without a closing tag\n    isClosingEndTag = closingToken.type === Tokenizer.END_TAG_TOKEN && tn === closingToken.tagName;\n\n    if (isClosingEndTag) {\n      loc.endTag = {\n        line: ctLocation.line,\n        col: ctLocation.col,\n        startOffset: ctLocation.startOffset,\n        endOffset: ctLocation.endOffset\n      };\n    }\n\n    if (isClosingEndTag) loc.endOffset = ctLocation.endOffset;else loc.endOffset = ctLocation.startOffset;\n  }\n}\n\nexports.assign = function (parser) {\n  //NOTE: obtain Parser proto this way to avoid module circular references\n  var parserProto = Object.getPrototypeOf(parser),\n      treeAdapter = parser.treeAdapter,\n      attachableElementLocation = null,\n      lastFosterParentingLocation = null,\n      currentToken = null; //NOTE: patch _bootstrap method\n\n  parser._bootstrap = function (document, fragmentContext) {\n    parserProto._bootstrap.call(this, document, fragmentContext);\n\n    attachableElementLocation = null;\n    lastFosterParentingLocation = null;\n    currentToken = null; //OpenElementStack\n\n    parser.openElements.pop = function () {\n      setEndLocation(this.current, currentToken, treeAdapter);\n      OpenElementStack.prototype.pop.call(this);\n    };\n\n    parser.openElements.popAllUpToHtmlElement = function () {\n      for (var i = this.stackTop; i > 0; i--) setEndLocation(this.items[i], currentToken, treeAdapter);\n\n      OpenElementStack.prototype.popAllUpToHtmlElement.call(this);\n    };\n\n    parser.openElements.remove = function (element) {\n      setEndLocation(element, currentToken, treeAdapter);\n      OpenElementStack.prototype.remove.call(this, element);\n    };\n  }; //Token processing\n\n\n  parser._processTokenInForeignContent = function (token) {\n    currentToken = token;\n\n    parserProto._processTokenInForeignContent.call(this, token);\n  };\n\n  parser._processToken = function (token) {\n    currentToken = token;\n\n    parserProto._processToken.call(this, token); //NOTE: <body> and <html> are never popped from the stack, so we need to updated\n    //their end location explicitly.\n\n\n    if (token.type === Tokenizer.END_TAG_TOKEN && (token.tagName === $.HTML || token.tagName === $.BODY && this.openElements.hasInScope($.BODY))) {\n      for (var i = this.openElements.stackTop; i >= 0; i--) {\n        var element = this.openElements.items[i];\n\n        if (this.treeAdapter.getTagName(element) === token.tagName) {\n          setEndLocation(element, token, treeAdapter);\n          break;\n        }\n      }\n    }\n  }; //Doctype\n\n\n  parser._setDocumentType = function (token) {\n    parserProto._setDocumentType.call(this, token);\n\n    var documentChildren = this.treeAdapter.getChildNodes(this.document),\n        cnLength = documentChildren.length;\n\n    for (var i = 0; i < cnLength; i++) {\n      var node = documentChildren[i];\n\n      if (this.treeAdapter.isDocumentTypeNode(node)) {\n        node.__location = token.location;\n        break;\n      }\n    }\n  }; //Elements\n\n\n  parser._attachElementToTree = function (element) {\n    //NOTE: _attachElementToTree is called from _appendElement, _insertElement and _insertTemplate methods.\n    //So we will use token location stored in this methods for the element.\n    element.__location = attachableElementLocation || null;\n    attachableElementLocation = null;\n\n    parserProto._attachElementToTree.call(this, element);\n  };\n\n  parser._appendElement = function (token, namespaceURI) {\n    attachableElementLocation = token.location;\n\n    parserProto._appendElement.call(this, token, namespaceURI);\n  };\n\n  parser._insertElement = function (token, namespaceURI) {\n    attachableElementLocation = token.location;\n\n    parserProto._insertElement.call(this, token, namespaceURI);\n  };\n\n  parser._insertTemplate = function (token) {\n    attachableElementLocation = token.location;\n\n    parserProto._insertTemplate.call(this, token);\n\n    var tmplContent = this.treeAdapter.getTemplateContent(this.openElements.current);\n    tmplContent.__location = null;\n  };\n\n  parser._insertFakeRootElement = function () {\n    parserProto._insertFakeRootElement.call(this);\n\n    this.openElements.current.__location = null;\n  }; //Comments\n\n\n  parser._appendCommentNode = function (token, parent) {\n    parserProto._appendCommentNode.call(this, token, parent);\n\n    var children = this.treeAdapter.getChildNodes(parent),\n        commentNode = children[children.length - 1];\n    commentNode.__location = token.location;\n  }; //Text\n\n\n  parser._findFosterParentingLocation = function () {\n    //NOTE: store last foster parenting location, so we will be able to find inserted text\n    //in case of foster parenting\n    lastFosterParentingLocation = parserProto._findFosterParentingLocation.call(this);\n    return lastFosterParentingLocation;\n  };\n\n  parser._insertCharacters = function (token) {\n    parserProto._insertCharacters.call(this, token);\n\n    var hasFosterParent = this._shouldFosterParentOnInsertion(),\n        parent = hasFosterParent && lastFosterParentingLocation.parent || this.openElements.currentTmplContent || this.openElements.current,\n        siblings = this.treeAdapter.getChildNodes(parent),\n        textNodeIdx = hasFosterParent && lastFosterParentingLocation.beforeElement ? siblings.indexOf(lastFosterParentingLocation.beforeElement) - 1 : siblings.length - 1,\n        textNode = siblings[textNodeIdx]; //NOTE: if we have location assigned by another token, then just update end position\n\n\n    if (textNode.__location) textNode.__location.endOffset = token.location.endOffset;else textNode.__location = token.location;\n  };\n};","map":null,"metadata":{},"sourceType":"script"}