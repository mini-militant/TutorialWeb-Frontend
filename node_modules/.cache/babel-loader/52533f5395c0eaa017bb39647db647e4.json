{"ast":null,"code":"'use strict';\n\nvar TransformStream = require('stream').Transform,\n    DevNullStream = require('./dev_null_stream'),\n    inherits = require('util').inherits,\n    Tokenizer = require('../tokenizer'),\n    ParserFeedbackSimulator = require('./parser_feedback_simulator'),\n    mergeOptions = require('../common/merge_options');\n/**\n * @typedef {Object} SAXParserOptions\n *\n * @property {Boolean} [locationInfo=false] - Enables source code location information for the tokens.\n * When enabled, each token event handler will receive {@link LocationInfo} (or {@link StartTagLocationInfo})\n * object as its last argument.\n */\n\n\nvar DEFAULT_OPTIONS = {\n  locationInfo: false\n};\n/**\n * Streaming [SAX]{@link https://en.wikipedia.org/wiki/Simple_API_for_XML}-style HTML parser.\n * A [transform stream](https://nodejs.org/api/stream.html#stream_class_stream_transform)\n * (which means you can pipe *through* it, see example).\n * @class SAXParser\n * @memberof parse5\n * @instance\n * @extends stream.Transform\n * @param {SAXParserOptions} options - Parsing options.\n * @example\n * var parse5 = require('parse5');\n * var http = require('http');\n * var fs = require('fs');\n *\n * var file = fs.createWriteStream('/home/google.com.html');\n * var parser = new parse5.SAXParser();\n *\n * parser.on('text', function(text) {\n *  // Handle page text content\n *  ...\n * });\n *\n * http.get('http://google.com', function(res) {\n *  // SAXParser is the Transform stream, which means you can pipe\n *  // through it. So, you can analyze page content and, e.g., save it\n *  // to the file at the same time:\n *  res.pipe(parser).pipe(file);\n * });\n */\n\nvar SAXParser = module.exports = function (options) {\n  TransformStream.call(this);\n  this.options = mergeOptions(DEFAULT_OPTIONS, options);\n  this.tokenizer = new Tokenizer(options);\n  this.parserFeedbackSimulator = new ParserFeedbackSimulator(this.tokenizer);\n  this.pendingText = null;\n  this.currentTokenLocation = void 0;\n  this.lastChunkWritten = false;\n  this.stopped = false; // NOTE: always pipe stream to the /dev/null stream to avoid\n  // `highWaterMark` hit even if we don't have consumers.\n  // (see: https://github.com/inikulin/parse5/issues/97#issuecomment-171940774)\n\n  this.pipe(new DevNullStream());\n};\n\ninherits(SAXParser, TransformStream); //TransformStream implementation\n\nSAXParser.prototype._transform = function (chunk, encoding, callback) {\n  if (!this.stopped) {\n    this.tokenizer.write(chunk.toString('utf8'), this.lastChunkWritten);\n\n    this._runParsingLoop();\n  }\n\n  this.push(chunk);\n  callback();\n};\n\nSAXParser.prototype._flush = function (callback) {\n  callback();\n};\n\nSAXParser.prototype.end = function (chunk, encoding, callback) {\n  this.lastChunkWritten = true;\n  TransformStream.prototype.end.call(this, chunk, encoding, callback);\n};\n/**\n * Stops parsing. Useful if you want the parser to stop consuming CPU time once you've obtained the desired info\n * from the input stream. Doesn't prevent piping, so that data will flow through the parser as usual.\n *\n * @function stop\n * @memberof parse5#SAXParser\n * @instance\n * @example\n * var parse5 = require('parse5');\n * var http = require('http');\n * var fs = require('fs');\n *\n * var file = fs.createWriteStream('/home/google.com.html');\n * var parser = new parse5.SAXParser();\n *\n * parser.on('doctype', function(name, publicId, systemId) {\n *  // Process doctype info ans stop parsing\n *  ...\n *  parser.stop();\n * });\n *\n * http.get('http://google.com', function(res) {\n *  // Despite the fact that parser.stop() was called whole\n *  // content of the page will be written to the file\n *  res.pipe(parser).pipe(file);\n * });\n */\n\n\nSAXParser.prototype.stop = function () {\n  this.stopped = true;\n}; //Internals\n\n\nSAXParser.prototype._runParsingLoop = function () {\n  do {\n    var token = this.parserFeedbackSimulator.getNextToken();\n    if (token.type === Tokenizer.HIBERNATION_TOKEN) break;\n\n    if (token.type === Tokenizer.CHARACTER_TOKEN || token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN || token.type === Tokenizer.NULL_CHARACTER_TOKEN) {\n      if (this.options.locationInfo) {\n        if (this.pendingText === null) this.currentTokenLocation = token.location;else this.currentTokenLocation.endOffset = token.location.endOffset;\n      }\n\n      this.pendingText = (this.pendingText || '') + token.chars;\n    } else {\n      this._emitPendingText();\n\n      this._handleToken(token);\n    }\n  } while (!this.stopped && token.type !== Tokenizer.EOF_TOKEN);\n};\n\nSAXParser.prototype._handleToken = function (token) {\n  if (this.options.locationInfo) this.currentTokenLocation = token.location;\n  if (token.type === Tokenizer.START_TAG_TOKEN)\n    /**\n     * Raised when the parser encounters a start tag.\n     * @event startTag\n     * @memberof parse5#SAXParser\n     * @instance\n     * @type {Function}\n     * @param {String} name - Tag name.\n     * @param {Array} attrs - List of attributes in the `{ name: String, value: String, prefix?: String }` form.\n     * @param {Boolean} selfClosing - Indicates if the tag is self-closing.\n     * @param {StartTagLocationInfo} [location] - Start tag source code location info.\n     * Available if location info is enabled in {@link SAXParserOptions}.\n     */\n    this.emit('startTag', token.tagName, token.attrs, token.selfClosing, this.currentTokenLocation);else if (token.type === Tokenizer.END_TAG_TOKEN)\n    /**\n     * Raised then parser encounters an end tag.\n     * @event endTag\n     * @memberof parse5#SAXParser\n     * @instance\n     * @type {Function}\n     * @param {String} name - Tag name.\n     * @param {LocationInfo} [location] - End tag source code location info.\n     * Available if location info is enabled in {@link SAXParserOptions}.\n     */\n    this.emit('endTag', token.tagName, this.currentTokenLocation);else if (token.type === Tokenizer.COMMENT_TOKEN)\n    /**\n     * Raised then parser encounters a comment.\n     * @event comment\n     * @memberof parse5#SAXParser\n     * @instance\n     * @type {Function}\n     * @param {String} text - Comment text.\n     * @param {LocationInfo} [location] - Comment source code location info.\n     * Available if location info is enabled in {@link SAXParserOptions}.\n     */\n    this.emit('comment', token.data, this.currentTokenLocation);else if (token.type === Tokenizer.DOCTYPE_TOKEN)\n    /**\n     * Raised then parser encounters a [document type declaration]{@link https://en.wikipedia.org/wiki/Document_type_declaration}.\n     * @event doctype\n     * @memberof parse5#SAXParser\n     * @instance\n     * @type {Function}\n     * @param {String} name - Document type name.\n     * @param {String} publicId - Document type public identifier.\n     * @param {String} systemId - Document type system identifier.\n     * @param {LocationInfo} [location] - Document type declaration source code location info.\n     * Available if location info is enabled in {@link SAXParserOptions}.\n     */\n    this.emit('doctype', token.name, token.publicId, token.systemId, this.currentTokenLocation);\n};\n\nSAXParser.prototype._emitPendingText = function () {\n  if (this.pendingText !== null) {\n    /**\n     * Raised then parser encounters text content.\n     * @event text\n     * @memberof parse5#SAXParser\n     * @instance\n     * @type {Function}\n     * @param {String} text - Text content.\n     * @param {LocationInfo} [location] - Text content code location info.\n     * Available if location info is enabled in {@link SAXParserOptions}.\n     */\n    this.emit('text', this.pendingText, this.currentTokenLocation);\n    this.pendingText = null;\n  }\n};","map":null,"metadata":{},"sourceType":"script"}